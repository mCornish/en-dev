<h1>Sync 1</h1>


<p>
    The following pseudo-code expresses the steps that would be performed by a client in order to synchronize with the service.
</p>

<div class="toggle" ng-init="serv = false">
    <p class="toggle__button" ng-click="serv = !serv" ng-class="serv ? 'toggle--open' : ''">
        Service variables
    </p>
    <ul class="standard-list" ng-show="serv">
        <li>
            <span class="courier">updateCount</span> – the highest USN given out within the account
        </li>
        <li>
            <span class="courier">recoverySyncBefore</span> – the cut-off date for caching clients to perform a
            recovery sync process. This value may correspond to a time of a serious server issue that would invalidate client data.
        </li>
        <li>
            <span class="courier">fullSyncBefore</span> – the cut-off date for old caching clients to perform a full synchronization. This value may correspond to the point where historic data (e.g. regarding expunged objects) was wiped from the account on the service.
        </li>
    </ul>
</div>

<div class="toggle" ng-init="client = false">
    <p class="toggle__button" ng-click="client = !client" ng-class="client ? 'toggle--open' : ''">
        Client variables
    </p>
    <ul class="standard-list" ng-show="client">
        <li>
            <span class="courier">lastUpdateCount</span> – the server’s updateCount at the last sync
        </li>
        <li>
            <span class="courier">lastSyncTime</span> – the time of the last sync (as given by the service)
        </li>
    </ul>
</div>

<div class="toggle" ng-init="auth = false">
    <p class="toggle__button" ng-click="auth = !auth" ng-class="auth ? 'toggle--open' : ''">
        Authentication
    </p>
    <ul class="standard-list toggle__list" ng-show="auth">
        <li>
            <p>
                All API’s except the UserStore.authenticate, UserStore.authenticateBySteamID, UserStore.registerUser and UserStore.sendForgottenPassword will require the query string to have the authentication token set in it:
            </p>
            <p>
                http://server.com/enwservices/xrpc?authToken=TOKEN&clientid=CLIENTID
            </p>
            <p>
                http://server.com/enwservices/api/1.0/userstore?authToken=TOKEN&clienti d=CLIENTID
            </p>
            <p>
                http://server.com/enwservices/api/1.0/referencestore?authToken=TOKEN&amp;clientid=CLIENTID
            </p>
        </li>
        <li>
            All API’s support HTTPS and Authentication API’s require HTTPS.
        </li>
        <li>
            Production URL’s are burned into the desktop clients and an XML file override is supported to allow an application to point to QA and Dev environments.
        </li>
    </ul>
    <ol class="standard-list toggle__list" ng-show="auth">
        <li>
            Authenticate to the service using UserStore.authenticate(username,pwd,key,secret) over HTTPS.
            <ol class="standard-list">
                <li>
                    Receive opaque authenticationToken string to use for all other operations.
                </li>
                <li>
                    Record expiration time of the authenticationToken. If token is near expiration* before any request to the server, get a new token (with a later expiration) via UserStore.refreshAuthentication(...) (over HTTPS only).
                </li>
            </ol>
        </li>
        <li>
            All API’s support HTTPS and Authentication API’s require HTTPS.
        </li>
        <li>
            Production URL’s are burned into the desktop clients and an XML file override is supported to allow an application to point to QA and Dev environments.
        </li>
    </ol>
</div>





a.
b.
* “Near Expiration” This is meant to reduce the load on the server for creating new tokens. For this initial release of X6, we will follow this methodology:
i. At the start of “Sync”, if the client has not persisted an authentication token.
a. Authenticate per above
b. Proceed with sync per below.
ii. At the start of “Sync”, if the client has persisted an authentication
token.
a. Refresh the token per above.
i. If the refresh succeeds, proceed with sync per below.
ii. If the refresh fails for any reason, discard the existing token and re-authenticate per above and proceed with Sync per below.
iii. Optionally, refresh the token at the end of sync.
10
2. Ensure this database has not been synchronized to any other users. If it has, ensure there are no traces of any sync information in the client DB. This is mostly an edge case where one of a few things may have occurred:
a. User is now configuring a copy of a library they received from a peer(ENLX, thumb drive, etc)
b. User has previously configured this library as their sync library, then configured a different library and is now setting this library as their sync library again.
c. User is changing the service account they wish to sync with. This is not the same as changing their email for their service account.
11
Sync Status
Call ReferenceStore.getSyncState(...) to get the server’s updateCount, currentTime, recoverySyncBefore and fullSyncBefore values.
a. Iftheclienthasneversynchedwiththeservicebefore,continueto
Initial Sync.
b. If ( recoverySyncBefore > lastSyncTime), continue to Recovery
Sync.
c. If ( fullSyncBefore > lastSyncTime), continue to Full Sync.
d. If (updateCount = lastUpdateCount), the server has no updates.
Skip to Send Changes.
e. Otherwise, perform an incremental update sync (go to Incremental
Sync)
12
Initial Sync
General Algorithm:
1. Create a local list of GroupSet items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr
ies,filter)
2. Process the list of GroupSet items in order. Add each item to the client DB unless it’s identified as being expunged.
3. Create a local list of Group items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0 ,maxEnt
     ries,filter)
4. Process the list of Group items in order. Add each item to the client DB unless it’s identified as being expunged.
5. Create a local list of Reference items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr
ies,filter)
6. Process the list of Reference items in order. Add each item to the client DB unless it’s identified as being expunged.
7. Store the server’s updateCount(from getSyncState) to lastUpdateCount and the server’s current time(from getSyncState) to lastSyncTime.
8. Go to Send Changes.
Specifics:
a. ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr ies,filter) will return the metadata for at most maxEntries objects (of any type), starting from the least-recently-modified object in the account. This includes the full state of “small” objects like Groups, but only includes the metadata for References (unless option to include all reference content is set), FileResources and FigureResources. Binary resource content must be requested separately, later. Expunged (deleted permanently) objects are included by (GUID) only.
b. Call
ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr ies,filter) to get the first block of data objects from the service. If
chunk’s chunkHighUSN is less than chunk’s updateCount, buffer the chunk and request the next chunk by calling ReferenceStore.getFilteredSyncChunk with afterUSN = chunkHighUSN. (This can be done safely in spite of a time gap between chunks).
c. The binary content of resources will not be transmitted as part of the sync block. The biblio content of References is not transmitted by default and can be requested via the sync chunk filter or separately via ReferenceStore.getReference(...).
13
i. The service will always return metadata with Reference chunks. This includes group membership information, favorites rating, read status, reference timestamps, Figure and File metadata, etc.
ii. Reference biblio data should always be pulled regardless of the biblioContentUpdated flag in the reference structure in the sync chunk that indicates whether or not the content should be retrieved via getReference. This is because this is “initial” sync and therefore the data is needed.
iii. The client should retrieve all Figure and File structures using appropriate API to retrieve the data from the service.
iv. Expunged group sets, groups, references, figures and files should be ignored.
14
Full Sync
General Algorithm:
1. Create a local list of GroupSet items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr
eis,filter)
2. Process the list of GroupSet items in order to construct the current state of the service.
3. Create a local list of Group items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr
ies,filter)
4. Process the list of Group items in order to construct the current state of the service.
5. Create a local list of Reference items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr
ies,filter)
6. Process the list of Reference items in order to construct the current state of the service.
7. For any items in the client list that have GUID’s but do not exist in the service list, delete the item from the client because these have been explicitly deleted from the service.
8. Store the server’s updateCount(from getSyncState) to lastUpdateCount and the server’s current time(from getSyncState) to lastSyncTime.
9. Go to Send Changes.
Specifics:
a. ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr ies,filter) will return the metadata for at most maxEntries objects (of any type), starting from the least-recently-modified object in the account. This includes the full state of “small” objects like Groups, but only includes the metadata for References (unless option to include all reference content is set), FileResources and FigureResources. Binary resource content must be requested separately, later. Expunged (deleted permanently) objects are included by (GUID) only.
b. Call
ReferenceStore.getFilteredSyncChunk(...,afterUSN=0,max Entries,filter) to get the first block of data objects from the service. If chunk’s chunkHighUSN is less than chunk’s updateCount, buffer the chunk and request the next chunk by calling ReferenceStore.getFilteredSyncChunk with afterUSN = chunkHighUSN. (This can be done safely in spite of a time gap between chunks).
c. If an item exists on the server, but not on the client, add to the client DB(unless it’s identified as being expunged).
d. If an item exists on the client, but not on the service:
15
i. If the client’s item has a “dirty flag” and there is a GUID and local USN, clear the GUID and local USN to mark the item as new on the client and upload later during “Send Changes”. This is being done because the user must’ve made changes that were never sent to the service and we wish to do no harm so we will upload the changed item to the service even though it may have been previously permanently deleted in the service.
ii. If the client’s item has no “dirty” flag and if it has previously been uploaded to the server(has GUID and local USN), then delete the item from the client because this client has no user changes that could be lost and the user has already permanently deleted the item from the service.
e. Ifanitemexistsonboththeclientandtheserver:
i. If they have the same USN and no “dirty” flag, then they’re in sync.
ii. If they have the same USN, but the client’s item has a “dirty” flag, then it should be uploaded to the server later.
iii. If the server’s item has a higher USN and the client has no “dirty” flag, then update the state of the client’s item with the server’s object.
iv. If the server’s item has a higher USN and the client has a “dirty” flag, then the object has been modified on both the server and the client. If possible, compare the server relative timestamps and favor the latest timestamp; otherwise, report the conflict for resolution.
f. If a GroupSet is deleted from the client, all of its Groups are deleted (unless it's the last GroupSet which cannot be deleted).
g. If a Group is deleted from the client, all of its References are only removed from the group membership and remain in the library and associated to any other groups it already belongs to. This means when UI deletes a group, it needs to manage group membership on its system and flag all affected References as dirty with respect to their metadata(which includes group membership).
h. The binary content of resources will not be transmitted as part of the sync block. The biblio content of References is not transmitted by default and can be requested via the sync chunk filter or separately via ReferenceStore.getReference(...).
i. The service will always return metadata with Reference chunks. This includes group membership information, favorites rating, read status, reference timestamps, Figure and File metadata, etc.
ii. If the reference biblio data was changed(tracked via separate USN on the server), then a flag in the reference structure in the sync chunk will indicate the content should be retrieved via getReference if it was not retrieved as part of the sync chunk.
iii. The client should inspect all Figure and File structures. If the service returned an item in these lists that is not on the client(as determined by GUID)and not already flagged for expungement on
16
the client, then add this item to the client using the appropriate API
to retrieve the data from the service.
iv. The client should also use the checksum and file length to compare
all Figure and File objects with what is on the client. If any of these are different, then update the client object with the server data. Keep in mind, you won’t get to this point if any of the figure, files, biblio or meta data has also changed on the client because this will have been flagged as a conflict.
v. When References are expunged, their Figure and File Resources are also expunged.
17
Recovery Sync
General Algorithm:
1. Create a local list of GroupSet items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr
ies,filter)
2. Process the list of GroupSet items in order to construct the current state of the service.
3. Create a local list of Group items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr
ies,filter)
4. Process the list of Group items in order to construct the current state of the service.
5. Create a local list of Reference items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr
ies,filter)
6. Process the list of Reference items in order to construct the current state of the service.
7. For any items in the client list that have GUID’s but do not exist in the service list, purge the GUID from the local item and send to the service as a new item.
8. Store the server’s updateCount(from getSyncState) to lastUpdateCount and the server’s current time(from getSyncState) to lastSyncTime.
9. Go to Send Changes.
Specifics:
a. ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr ies,filter) will return the metadata for at most maxEntries objects (of
any type), starting from the least-recently-modified object in the account. This includes the full state of “small” objects like Groups, but only includes the metadata for References (unless option to include all reference content is set), FileResources and FigureResources. Binary resource content must be requested separately, later. Expunged (deleted permanently) objects are included by (GUID) only.
b. Call
ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr ies,filter) to get the first block of data objects from the service. If
chunk’s chunkHighUSN is less than chunk’s updateCount, buffer the chunk and request the next chunk by calling ReferenceStore.getFilteredSyncChunk with afterUSN = chunkHighUSN. (This can be done safely in spite of a time gap between chunks).
c. If an item exists on the server, but not on the client, add to the client DB(unless it’s identified as being expunged).
d. If an item exists on the client, but not on the service:
18
i. If the client’s item has a GUID or local USN, clear the GUID and local USN to mark the item as new on the client and upload later during “Send Changes”.
e. If an item exists on both the client and the server:
i. If they have the same USN and no “dirty” flag, then they’re in
sync.
ii. If they have the same USN, but the client’s item has a “dirty”
flag, then it should be uploaded to the server later.
iii. If the server’s item has a higher USN and the client has no
“dirty” flag, then update the state of the client’s item with the
server’s object.
iv. If the server’s item has a higher USN and the client has a “dirty”
flag, then the object has been modified on both the server and the client. If possible, compare the server relative timestamps and favor the latest timestamp; otherwise, report the conflict for resolution.
f. If a GroupSet is deleted from the client, all of its Groups are deleted (unless it's the last GroupSet which cannot be deleted).
g. If a Group is deleted from the client, all of its References are only removed from the group membership and remain in the library and associated to any other groups it already belongs to. This means when UI deletes a group, it needs to manage group membership on its system and flag all affected References as dirty with respect to their metadata(which includes group membership).
h. The binary content of resources will not be transmitted as part of the sync block. The biblio content of References is not transmitted by default and can be requested via the sync chunk filter or separately via ReferenceStore.getReference(...).
i. The service will always return metadata with Reference chunks. This includes group membership information, favorites rating, read status, reference timestamps, Figure and File metadata, etc.
ii. If the reference biblio data was changed(tracked via separate USN on the server), then a flag in the reference structure in the sync chunk will indicate the content should be retrieved via getReference if it was not retrieved as part of the sync chunk.
iii. The client should inspect all Figure and File structures. If the service returned an item in these lists that is not on the client(as determined by GUID(and not already flagged for expungement on the client), then add this item to the client using appropriate API to retrieve the data from the service.
iv. The client should also use the checksum and file length to compare all Figure and File objects with what is on the client. If any of these are different, then update the client object with the server data. Keep in mind, you won’t get to this point if any of
19
the figure, files, biblio or meta data has also changed on the
client because this will have been flagged as a conflict. v. When References are expunged, their Figure and File
Resources are also expunged.
20
Incremental Sync
General Algorithm:
1. Create a local list of GroupSet items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntr
ies,filter)
2. Process the list of GroupSet items in order to construct the current state of the service.
3. Create a local list of Group items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=lastUpdat
     eCount,maxEntries, filter)
4. Process the list of Group items in order to add/update items from the server to the client.
5. Create a local list of Reference items via
     ReferenceStore.getFilteredSyncChunk(afterUSN=lastUpdat
     eCount,maxEntries,filter)
6. Process the list of Reference items in order to add/update items from the server to the client.
7. Store the server’s updateCount(from getSyncState) to lastUpdateCount and the server’s current time(from getSyncState) to lastSyncTime.
8. Continue to Send Changes.
Specifics:
a. If an item exists in the server’s list, but not in the client, add to the client DB.
b. If an item exists in both the client and the server:
i. If they have the same USN and no “dirty” flag, then they’re in sync.
ii. If they have the same USN, but the client’s item has a “dirty” flag, then it should be uploaded to the server later.
iii. If the server’s item has a higher USN and the client has no “dirty” flag, then update the state of the client’s item with the server’s object.
iv. If the server’s item has a higher USN and the client has a “dirty” flag, then the object has been modified on both the server and the client. If possible, compare the server relative timestamps and favor the latest timestamp; otherwise, report the conflict for resolution.
c. Ifa GroupSet is deleted from the client, all of its Groups are deleted (unless it's the last GroupSet which cannot be deleted).
d. If a Group is deleted from the client, all of its References are only removed from the group membership and remain in the library and associated to any other groups it already belongs to. This means when UI deletes a group, it needs to manage group membership on it’s system and flag all affected References as dirty with respect to their metadata(which includes group membership).
e. The binary content of resources will not be transmitted as part of the sync block. The biblio content of References is not transmitted by default and
21
can be requested via the sync chunk filter or separately via ReferenceStore.getReference(...).
i. The service will always return metadata with Reference chunks. This includes changes to group membership, favorites rating, read status, timestamps, Figures and Files, etc.
ii. If the reference data was changed(tracked via separate USN on the server), then a flag in the reference structure in the sync chunk will indicate the content should be retrieved via getReference if it was not retrieved as part of the sync chunk.
iii. The client should inspect all Figure and File structures. If the service returned an item in these lists that is not on the client(as determined by GUID(and not already flagged for expungement on the client),), then add this item to the client using appropriate API to retrieve the data from the service.
iv. The client should also use the checksum and file length to compare all Figure and File objects with what is on the client. If any of these are different, then update the client object with the server data. Keep in mind, you won’t get to this point if any of the figure, files, biblio or meta data has also changed on the client because this will have been flagged as a conflict.
v. This entire item could potentially even be easier, but more expensive if instead the client just wants to pull all the figure and file objects when a reference has changed.
vi. When References are expunged, their Figure and File Resources are also expunged.
f. For
resource from the client, if present.
each expunged Figure and File Resource, remove the corresponding
g. For each expunged Reference, remove the corresponding Reference from the client, if present.
h. Deleted References are references that are placed into the Trash.
i. Expunging a GroupSet implies permanent removal of the group set and
all of its groups.
j. Expunging a Group implies permanent removal of the group and
disassociating references from those groups. This means references(and their resources) remain in the library.
22
Send Changes
General Algorithm:
1. Sendexpungedattachmentsandfiguresvia
     ReferenceStore.expungeResource(...)
2. Send expunged references via
     ReferenceStore.expungeReference(...)
3. Send expunged groups via ReferenceStore.expungeGroup(...)
4. Send new groups via ReferenceStore.createGroup(...)
5. SendmodifiedgroupsviaReferenceStore.updateGroup(...)
6. Send expunged groups via ReferenceStore.expungeGroupSet(...)
7. Send new groups via ReferenceStore.createGroupSet(...)
8. SendmodifiedgroupsviaReferenceStore.updateGroupSet(...)
9. Send new references via ReferenceStore.createReference(...)
10.Send modified references via
     ReferenceStore.updateReference(...)
11.Send modified figures via
     ReferenceStore.updateFigureResource(...)
12.Send modified attachments via
     ReferenceStore.updateFileResource(...)
Specifics:
a. An item is new if no GUID has been assigned to it.
b. An item is modified if it has a GUID and its dirty flag is set.
c. The client is required to transmit the full data (Reference contents,
resource data, recognition data) for each Reference sent using ReferenceStore.createReference(...), and is required to transmit such data if modified as part of any call to ReferenceStore.updateReference(...). I.e. the Reference must be uploaded as one message ... its parts may not be transmitted later.

<div class="toggle" ng-init="incSync = false">
    <p class="toggle__button" ng-click="incSync = !incSync" ng-class="incSync ? 'toggle--open' : ''">
        Incremental Sync
    </p>

    <p class="toggle__list" ng-show="incSync">
        <em>General Algorithm:</em>
    </p>

    <ol class="standard-list toggle__list" ng-show="incSync">
        <li>
            Create a local list of GroupSet items via <span class="courier">ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntries,filter)</span>.
        </li>
        <li>
            Process the list of GroupSet items in order to construct the current state of the service.
        </li>
        <li>
            Create a local list of Group items via <span class="courier">ReferenceStore.getFilteredSyncChunk(afterUSN=0 ,maxEntries,filter)</span>.
        </li>
        <li>
            Process the list of Group items in order to add/update items from the server to the client.
        </li>
        <li>
            Create a local list of Reference items via <span class="courier">ReferenceStore.getFilteredSyncChunk(afterUSN=0,maxEntries,filter)</span>.
        </li>
        <li>
            Process the list of Reference items in order to add/update items from the server to the client.
        </li>
        <li>
            Store the server’s updateCount(from <span class="courier">getSyncState</span>) to lastUpdateCount and the server’s current time(from <span class="courier">getSyncState</span>) to lastSyncTime.
        </li>
        <li>
            Go to <b>Send Changes</b>.
        </li>
    </ol>

    <p class="toggle__list" ng-show="incSync">
        <em>Specifics:</em>
    </p>

    <ol class="standard-list toggle__list" ng-show="incSync">
        <li>
            If an item exists in the server’s list, but not in the client, add to the client DB.
        </li>
        <li>
            If an item exists in both the client and the server:
            <ol class="standard-list">
                <li>
                    If they have the same USN and no “dirty” flag, then they’re in sync.
                </li>
                <li>
                    If they have the same USN, but the client’s item has a “dirty” flag, then it should be uploaded to the server later.
                </li>
                <li>
                    If the server’s item has a higher USN and the client has no “dirty” flag, then update the state of the client’s item with the server’s object.
                </li>
                <li>
                    If the server’s item has a higher USN and the client has a “dirty” flag, then the object has been modified on both the server and the client. If possible, compare the server relative timestamps and favor the latest timestamp; otherwise, report the conflict for resolution.
                </li>
            </ol>
        </li>
        <li>
            If a GroupSet is deleted from the client, all of its Groups are deleted (unless it's the last GroupSet which cannot be deleted).
        </li>
        <li>
            If a Group is deleted from the client, all of its References are only removed from the group membership and remain in the library and associated to any other groups it already belongs to. This means when UI deletes a group, it needs to manage group membership on it’s system and flag all affected References as dirty with respect to their metadata(which includes group membership).
        </li>
        <li>
            The binary content of resources will not be transmitted as part of the sync block. The biblio content of References is not transmitted by default and can be requested via the sync chunk filter or separately via ReferenceStore.getReference(...).
            <ol class="standard-list">
                <li>
                    The service will always return metadata with Reference chunks. This includes changes to group membership, favorites rating, read status, timestamps, Figures and Files, etc.
                </li>
                <li>
                    If the reference data was changed(tracked via separate USN on the server), then a flag in the reference structure in the sync chunk will indicate the content should be retrieved via getReference if it was not retrieved as part of the sync chunk.
                </li>
                <li>
                    The client should inspect all Figure and File structures. If the service returned an item in these lists that is not on the client(as determined by GUID(and not already flagged for expungement on the client),), then add this item to the client using appropriate API to retrieve the data from the service.
                </li>
                <li>
                    The client should also use the checksum and file length to compare all Figure and File objects with what is on the client. If any of these are different, then update the client object with the server data. Keep in mind, you won’t get to this point if any of the figure, files, biblio or meta data has also changed on the client because this will have been flagged as a conflict.
                </li>
                <li>
                    This entire item could potentially even be easier, but more expensive if instead the client just wants to pull all the figure and file objects when a reference has changed.
                </li>
                <li>
                    When References are expunged, their Figure and File Resources are also expunged.
                </li>
            </ol>
        </li>
        <li>
            For each expunged Figure and File Resource, remove the corresponding
            resource from the client, if present.
        </li>
        <li>
            For each expunged Reference, remove the corresponding Reference from the client, if present.
        </li>
        <li>
            Deleted References are references that are placed into the Trash.
        </li>
        <li>
            Expunging a GroupSet implies permanent removal of the group set and all of its groups.
        </li>
        <li>
            Expunging a Group implies permanent removal of the group and
            disassociating references from those groups. This means references(and their resources) remain in the library.
        </li>
    </ol>
</div>
